### 队列实现栈 [原题](https://leetcode-cn.com/problems/implement-stack-using-queues)
@zhanf
思路总结：队列FIFO(先进先出) 栈FILO(先进后出)  

分析栈先进后出pop时队列数据有两种情况:
1. 已经倒置所以直接poll，push时用两个队列来回倒数据，保证队列中的数据倒置；
2. 未倒置所以pop时倒置再poll,但top跟pop逻辑类似，区分会增加复杂度，也没找到合适方法；  

所以采用第一种方式

````
class MyStack {

    private var queue1: Queue<Int> = LinkedList<Int>()
    private var queue2: Queue<Int> = LinkedList<Int>()

    fun push(x: Int) {
        queue1.offer(x)
        while (!queue2.isEmpty()) {
            queue1.offer(queue2.poll())
        }
        val temp = queue1
        queue1 = queue2
        queue2 = temp
    }

    fun pop(): Int {
        if (empty()) return -1
        return queue2.poll()
    }

    fun top(): Int {
        if (empty()) return -1
        return queue2.peek()
    }

    fun empty(): Boolean {
        return queue2.isEmpty()
    }

}
````

### 栈实现队列 [原题](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

@skiiyis  
思路总结：队列FIFO 栈FILO 所以主要的是队列的出队方法需要栈来模拟，这种模拟方式就是需要一个栈来倒序放置队列中的元素，然后栈中元素出栈时可模拟队列出队。  

appendTail方法 时间复杂度：O(1), 空间复杂度 O(1)  
deleteHead方法 时间复杂度：O(n), 空间复杂度 O(n)
```
class CQueue() {

    val appendStack = Stack<Int>()
    val deleteStack = Stack<Int>()

    fun appendTail(value: Int) {
        appendStack.push(value)
    }

    fun deleteHead(): Int {
        if (deleteStack.isEmpty()) {
            while (appendStack.isNotEmpty()) {
                deleteStack.push(appendStack.pop())
            }
        }
        return if (deleteStack.isNotEmpty()) {
            deleteStack.pop()
        } else {
            -1
        }
    }

}
```
### 堆排序
### 抖音跨平台方向 - 面试真题 - 二叉树的最近公共祖先 [原题](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

@skiiyis  
思路总结：dfs遍历的过程中记录根节点到两个目标节点的路径。再比较两个路径中相同的部分最后一个节点即最近公共祖先  

时间复杂度：O(n), 空间复杂度 O(n)  
```
    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {
        if (p == null || q == null) return null
        val pPath = mutableListOf<TreeNode>()
        val qPath = mutableListOf<TreeNode>()
        dfs(root, p, pPath)
        dfs(root, q, qPath)
        var i = 0
        while (true) {
            if (pPath.getOrNull(i) == null || qPath.getOrNull(i) == null) {
                return pPath.getOrNull(i - 1)
            }
            if (pPath.getOrNull(i) != qPath.getOrNull(i)) {
                return pPath[i - 1]
            }
            i++
        }
    }

    fun dfs(root: TreeNode?, target: TreeNode, path: MutableList<TreeNode>): MutableList<TreeNode>? {
        if (root == null) return null
        path.add(root)
        if (root == target) {
            return path
        } else {
            val leftDFS = dfs(root.left, target, path)
            if (leftDFS != null) return leftDFS
            val rightDFS = dfs(root.right, target, path)
            if (rightDFS != null) return rightDFS
            path.remove(root)
            return null
        }
    }
````
