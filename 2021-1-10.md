### 队列实现栈 [原题](https://leetcode-cn.com/problems/implement-stack-using-queues)
### 栈实现队列 [原题](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

@skiiyis  
思路总结：队列FIFO 栈FILO 所以主要的是队列的出队方法需要栈来模拟，这种模拟方式就是需要一个栈来倒序放置队列中的元素，然后栈中元素出栈时可模拟队列出队。  

appendTail方法 时间复杂度：O(1), 空间复杂度 O(1)  
deleteHead方法 时间复杂度：O(n), 空间复杂度 O(n)  
```
class CQueue() {

    val appendStack = Stack<Int>()
    val deleteStack = Stack<Int>()

    fun appendTail(value: Int) {
        appendStack.push(value)
    }

    fun deleteHead(): Int {
        if (deleteStack.isEmpty()) {
            while (appendStack.isNotEmpty()) {
                deleteStack.push(appendStack.pop())
            }
        }
        return if (deleteStack.isNotEmpty()) {
            deleteStack.pop()
        } else {
            -1
        }
    }

}
```
### 堆排序
### 抖音跨平台方向 - 面试真题 - 二叉树的最近公共祖先 [原题](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

@skiiyis  
思路总结：dfs遍历的过程中记录根节点到两个目标节点的路径。再比较两个路径中相同的部分最后一个节点即最近公共祖先  

时间复杂度：O(n), 空间复杂度 O(n)  
```
    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {
        if (p == null || q == null) return null
        val pPath = mutableListOf<TreeNode>()
        val qPath = mutableListOf<TreeNode>()
        dfs(root, p, pPath)
        dfs(root, q, qPath)
        var i = 0
        while (true) {
            if (pPath.getOrNull(i) == null || qPath.getOrNull(i) == null) {
                return pPath.getOrNull(i - 1)
            }
            if (pPath.getOrNull(i) != qPath.getOrNull(i)) {
                return pPath[i - 1]
            }
            i++
        }
    }

    fun dfs(root: TreeNode?, target: TreeNode, path: MutableList<TreeNode>): MutableList<TreeNode>? {
        if (root == null) return null
        path.add(root)
        if (root == target) {
            return path
        } else {
            val leftDFS = dfs(root.left, target, path)
            if (leftDFS != null) return leftDFS
            val rightDFS = dfs(root.right, target, path)
            if (rightDFS != null) return rightDFS
            path.remove(root)
            return null
        }
    }
```
